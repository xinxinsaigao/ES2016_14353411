
#Deadlock(死锁)
-------------------------------------------------------------------
##代码详解
-------------  

**关键字synchronized:**
>当它用来修饰一个方法或者一个代码块时，能够  
保证在同一个时刻最多只有一个线程执行该段代码；    

>当一个线程访问object的一个synchronized同步代  
码块或者同步方法时，其他线程对object中所有其  
它synchronized同步代码块或同步方法的访问将被  
阻塞。  

------------------------------------------------------------------ 

* 实例化函数a和函数b；
* 创建Deadlock线程；后创建t线程；
* t.start()后，线程t被插入到调度队列中，当  
调度到他的时候，就跑到run()，执行其中代码。  

----------------------------------------------------
##结果分析
-------------  
编译Deadlock.java:
在第21次时产生了死锁。  
![结果图1](http://a2.qpic.cn/psb?/V10xhQuy3m7suY/lFk8lJgICpDypRonZgY6iCXIkpHWVgVyQljsef0LSdI!/b/dAwBAAAAAAAA&bo=rQFqAAAAAAADAOM!&rf=viewer_4)
![结果图2](http://a3.qpic.cn/psb?/V10xhQuy3m7suY/WJkpWjiEIPcFmptQzC72UbFcZw0XfUOPUkQwHDmFZ04!/b/dI8AAAAAAAAA&bo=DwGlAgAAAAADAIw!&rf=viewer_4)  
      
----------------------------------------------------------------------------------  
##产生死锁的四个必要条件
------------------------------   
 
**互斥条件：一个资源每次只能被一个进程使用**    
**请求与保持条件：一个进程因为请求资源而阻塞的同时，对已有的资源保持不放**  
**不剥夺条件：进程已获得的资源，在未被完全使用之前，不能剥夺**  
**循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。**  

--------------------------------------------------------------------------------------------
##这次实验会产生死锁的原因
---------------------------------
A类函数和B类函数会互相申请对方的资源，但是在两个进程Deadlock和t之间，每次先run函数b，在回头运行函数a，这个过程中a要申请b的资源，还要等待b释放已经得到的资源；当count值也就是延时不够长的情况下，就会导致死锁。
